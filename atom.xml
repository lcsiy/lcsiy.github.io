<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-21T07:15:49.755Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程</title>
    <link href="http://example.com/2021/03/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://example.com/2021/03/21/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</id>
    <published>2021-03-21T07:16:08.835Z</published>
    <updated>2021-03-21T07:15:49.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程<a id="more"></a></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>软件=程序+数据+文档</strong></li><li>程序：按事先设计的功能和性能需求执行的指令序列</li><li>数据：是程序能正常操纵信息的数据结构</li><li>文档：与程序开发、维护和使用有关的图文材料 </li><li><strong>软件的特征：</strong></li><li><strong>软件的分类</strong>：</li><li>系统软件：操作系统、数据库管理系统、设备驱动程序、通信处理程序</li><li>支撑软件：文本编辑软件、文件格式化程序、磁盘或磁带间数据传输的程序、程序库系统、支持需求分析、设计、实现、测试和支持管理的软件</li><li>应用软件：商业数据处理软件、工程与科学计算软件、系统仿真软件、智能产品嵌入软件</li><li><strong>软件发展的原因：</strong></li><li>计算需求：软件必须适应新的计算环境或技术；</li><li>嵌入需求：软件必须拓展，以满足和新一代系统或数据库之间的互操作性；</li><li>业务需求：软件必须改善，以实现新的业务需求；</li><li>软件必须重新设计，使其在新的网络环境是可用的。</li><li><strong>软件危机：</strong>在计算机软件的开发和维护过程中所遇到的一系列严重问题。 如：项目超出预算、超时、质量差、项目难以管理代码难以维护等；现在通常为成本快速增加、需求增长。</li><li>产生原因：软件本身逻辑部件问题、规模庞大；使用不正确的开发方法</li><li><strong>软件工程</strong>：IEEE计算机协会将软件工程定义为：（1）应用系统化的、学科化的、定量的方法，来开发、运行和维护软件，即，将工程应用到软件。（2）对（1）中各种方法的研究。</li><li>目标：在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。</li><li>软件工程三要素：方法、工具、过程。</li><li>软件工程的发展已经历了四个重要阶段：1传统的软件工程、2对象工程、3过程工程以及4构件工程。</li><li>软件工程的7个原则：使用阶段性生命周期计划的管理、进行连续的验证、保证严格的产品控制、使用现代编程工具/工程实践、保持清晰的责任分配、用更好更少的人、保持过程改进。</li></ul><h3 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a><strong>软件过程模型</strong></h3><ul><li><p><strong>软件过程</strong>是在工作产品构建过程中，所需完成的活动、动作和任务的集合。</p></li><li><p><strong>软件过程模型</strong>是软件开发全部过程、活动和任务的结构框架。它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。</p><p><strong>瀑布模型</strong>：</p><ul><li>软件开发过程与软件生命周期一致；线性模型、推迟实现的观点、是一种以文档为驱动的模型。</li><li>缺点：增加工作量、开发风险大、早期错误发现晚、不适应需求变化；</li><li>瀑布模型适用于系统需求明确且稳定、技术成熟、工程管理较严格的场合，如军工、航天、医疗。</li></ul><p><strong>原型模型：</strong></p><ul><li>原型是指产品的一部分，原型化的目的是明确并完善需求，如演示原型；研究技术选择方案，如技术验证原型。</li><li>优点是减少需求不明确带来的风险；</li><li>缺点是构造原型采用的技术和工具不一定主流；快速建立的系统和连续修改导致质量低；客户意识不到质量问题。</li><li>适合场所：当客户定义一个总体目标集，但是他们并不清楚系统的具体输入和输出，或者开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式等，此时，原型模型是很好的选择。</li></ul><p><strong>增量模型</strong>：</p><ul><li>增量是满足用户需求的一个子集，能够完成一定功能、小而可用的软件。举例：文字处理软件：创建文本、组织文本、格式化文本；可创建三个增量。</li><li>特点：增量模型是一种非整体开发的模型，是一种进化式的开发过程；增量模型结合了原型模型的基本要素和迭代的特征，采用了基于时间的线性序列，每个线性序列都会输出该软件的一个“增量”；每个增量的开发可用瀑布或快速原型模型。</li><li>优点：不需要提供完整，只要有一个增量就能开发，开放式体系结构便于维护，初始阶段不需投入太多资源，产品逐步交付能适应需求变化，降低开发风险。</li><li>缺点：每个增量必须具备一定系统功能，难以给出合适增量、软件必须具备开放式体系结构、易退化为边做边改的方式，失去整体性。</li><li>适用于软件开发中需求可能发生变化、具有较大风险、或者希望尽早进入市场的项目。</li></ul><p><strong>螺旋模型：</strong></p><ul><li><p>把开发活动和风险管理结合起来控制风险；开发过程分成若干次迭代，每次迭代代表开发的一个阶段，对应模型中一条环线。</p></li><li><p>模型结合了瀑布模型和原型模型的特点</p></li><li><p>优点：有助于目标软件的适应能力，支持用户需求的动态变化；为用户参与所有关键决策提供了方便；降低开发风险。</p></li><li><p>缺点：每次迭代的效率不高，增加成本并推迟交付时间；需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高。</p></li><li><p>适用于需求不明确或者需求可能发生变化的大型复杂的软件系统。支持面向过程、面向对象等多种软件开发方法。</p><p><strong>喷泉模型：</strong></p></li><li><p>是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。各个阶段使用统一的概念和表示方法，生命周期各阶段无缝连接。</p></li><li><p>优点：各个阶段没有明显的界限，开发人员可以同步进行开发，提高效率，节省时间；</p></li><li><p>缺点：在各个开发阶段是重叠的，在开发过程中需要大量的开发人员；要求严格管理文档，使得审核的难度加大。</p></li><li><p>适用于面向对象开发。</p></li></ul><p><strong>基于构件的开发模型</strong>：</p><ul><li>考虑的焦点是集成而不是实现。构件/组件是指系统中模块化的、可更换的部分。</li><li>需求分析，和其他一样；构件分析，根据需求搜索构件，若无则修改；系统设计，考虑重用和集成；开发集成，将构件集成到系统中。</li><li>优点：软件复用思想，降低开发成本和风险，提高进度和质量；</li><li>缺点：模型复杂，商业构件不可修改；无法完全控制所开发系统的演化；项目划分的好坏直接影响项目结果的好坏。</li><li>适用于系统之间有共性的情况。</li></ul></li></ul><h4 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a><strong>敏捷软件开发</strong></h4><ul><li><strong>个体交互：</strong>个体和交互胜过过程和工具</li><li><strong>可工作软件</strong>：可以工作的软件胜过面面俱到的文档</li><li><strong>客户合作</strong>：客户合作胜过合同谈判</li><li><strong>响应变化</strong>：响应变化胜过遵循计划</li><li>虽然右边的项有价值，但我们更重视左边的项；高效工作、快速响应变化</li><li>敏捷软件过程是<strong>基本原理</strong>和<strong>开发准则</strong>的结合。</li><li>优点：快速响应变化和不确定性；可持续开发速度；适应商业竞争环境下的有限资源和有限时间</li><li>缺点：测试驱动开发可能导致通过测试但非用户期望；重构而不降低质量困难</li><li>适用于需求模糊且经常改变的场合，适合商业竞争环境下的项目。</li></ul><h4 id="选择软件过程模型"><a href="#选择软件过程模型" class="headerlink" title="选择软件过程模型"></a><strong>选择软件过程模型</strong></h4><ul><li>前期需求明确的情况下，尽量采用<strong>瀑布模型</strong></li><li>用户无系统使用经验，需求分析人员技能不足的情况下，尽量借助<strong>原型模型</strong></li><li>不确定因素很多，很多东西无法提前计划的情况下，尽量采用增量模型或螺旋模型</li><li>需求不稳定的情况下，尽量采用<strong>增量模型</strong></li><li>资金和成本无法一次到位的情况下，可采用<strong>增量模型</strong></li><li>对于完成多个独立功能开发的情况，可在需求分析阶段就进行功能并行，每个功能内部都尽量遵循<strong>瀑布模型</strong></li><li>全新系统的开发必须在总体设计完成后再开始增量或并行</li><li>编码人员经验较少的情况下，尽量不要采用敏捷或迭代模型</li><li>增量、迭代和原型可以综合使用，但每一次增量或迭代都必须有明确的交付和出口原则</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h3><ul><li>需求分析定义：确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。</li><li><strong>需求提炼</strong><ul><li>定义：对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成下一步的需求规格说明书。</li><li>核心：建立分析模型。</li><li>目的：是确保所有风险承担者尽早地对项目达成共识并对将来的产品有个相同而清晰的认识</li></ul></li><li><strong>需求规格说明书</strong><ul><li>定义：软件需求规格说明书（SRS）——软件系统的需求规格说明，是对待开发系统的行为的完整描述。它包含了功能性需求和非功能性需求。</li><li>标志：需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书。</li><li>目的：需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础</li></ul></li><li><strong>需求验证</strong><ul><li>工作：有效性检查、一致性检查、完备性检查、现实性检查</li><li>ppt</li></ul></li><li><strong>面向对象模型</strong><ul><li>数据模型（对象模型）：描述系统数据结构—-&gt;类图</li><li>行为模型（动态模型）：描述系统控制结构—-&gt;活动图、顺序图、状态图</li><li>功能模型：描述系统功能。—-&gt;用例图</li></ul></li></ul><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><ul><li>定义：在[IEEE610.12-90]中，软件设计定义为软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果。 </li><li>特点：<ul><li>设计必须实现在分析模型中包含的所有明确要求，必须满足客户所期望的所有隐含要求；</li><li>设计必须对编码人员、测试人员及后续的维护人员是可读可理解的；</li><li>设计应提供该软件的完整视图，从实现的角度解决数据、功能及行为等各领域方面的问题</li></ul></li><li>原则：设计应该是一种架构、模块化的、应该包含数据、体系结构、接口和组件各个方面、由软件需求分析过程中获得信息驱动，采用可重复使用的方法导出、应该采用正确清楚的表示法 </li><li>质量：功能性、易用性、可靠性、性能、可支持性（扩展性、适应性、可维护性）</li><li>概念：<ul><li>抽象：忽略具体的信息将不同事物看成相同事物的过程</li><li>体系结构：软件的整体结构和这种结构为系统提供概念上完整性的方式。</li><li>其他概念见于ppt</li><li>信息隐藏：模块间彼此相互隐藏即模块定义和设计时应当保证模块内的信息（过程和数据）不可以被不需要这些信息的其他模块访问 </li></ul></li><li></li></ul><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a><strong>面向对象设计</strong></h3><ul><li>面向对象设计强调定义软件对象，并且使这些软件对象相互协作来满足用户需求。</li><li>从面向对象分析到面向对象设计是一个逐渐扩充模型的过程。分析的结果通过细化直接生成设计结果。</li><li>四个层次：<ul><li>确定系统的总体结构和风格，构造系统的物理模型，将系统划分成不同的子系统。</li><li>中层设计：对每个用例进行设计，规划实现用例功能的关键类，确定类之间的关系。</li><li>进行底层设计：对每个类进行详细设计，设计类的属性和操作，优化类之间的关系。</li><li>补充实现非功能性需求所需要的类。</li></ul></li><li>强内聚：原则是一个类的属性和操作全部都是完成某个任务所必须的，其中不包括无用的属性和操作。</li><li>弱耦合：耦合主要指不同对象之间相互关联的程度。如果一个对象过多地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。应该通过类的公共接口实现耦合；</li><li>耦合方式：<ul><li>交互耦合：通过消息连接来实现的，则这种耦合就是交互耦合。设计时应降低消息连接的复杂程度。</li><li>继承耦合：继承耦合是一般化类与特殊化类之间的一种关联形式。设计时应认真分析他们之间的继承关系，如果抽象层次不合理，可能会造成对特殊化类的修改影响到一般化类，使得系统的稳定性降低。</li></ul></li><li>可重用性：<ul><li>开发环境提供的类库和已尽量使用已有的类，包括有的相似的类；</li><li>如果确实需要创建新类，则在设计这些新类时考虑将来的可重用性。</li></ul></li><li>框架：框架是一组可用于不同应用的类的集合。框架中的类通常是一些抽象类并且相互有联系，可以通过继承的方式使用这些类。</li></ul><h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a><strong>软件质量保证</strong></h3><ul><li>软件质量：符合明确规定的功能和性能要求；符合明确的开发标准；符合所有软件开发专业的共性、隐性标准，如易用性、可维护性等；</li><li>软件质量保证：遵照一定的软件生产标准、过程和步骤对软件质量进行评估的活动。</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;软件工程&quot;&gt;&lt;a href=&quot;#软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件工程&quot;&gt;&lt;/a&gt;软件工程</summary>
    
    
    
    <category term="软件" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="tag6" scheme="http://example.com/tags/tag6/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2021/03/21/Python/"/>
    <id>http://example.com/2021/03/21/Python/</id>
    <published>2021-03-21T07:16:03.542Z</published>
    <updated>2021-03-21T07:14:41.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python<a id="more"></a></h2><h4 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a><strong>字符串和编码</strong></h4><ul><li><p><strong>字符串和编码</strong>：ord()获取字符的整数表示，chr()，把编码转化为字符。</p></li><li><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)</span><br></pre></td></tr></table></figure></li><li><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;ABC&#x27;</span>.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xe4\xb8\xad\xff&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;中&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>我们通常在文件开头写上这两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></li><li><p>len（），计算字符数或字节数。</p></li><li><p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;growth rate: %d %%&#x27;</span> % <span class="number">7</span></span><br><span class="line"><span class="string">&#x27;growth rate: 7 %&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.format(<span class="string">&#x27;小明&#x27;</span>, <span class="number">17.125</span>)</span><br><span class="line"><span class="string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a><strong>list和tuple</strong></h4><ul><li><p>list可通过append追加元素 <code>classmates.append(&#39;Adam&#39;)</code>,插入则是<code>classmates.insert(1, &#39;Jack&#39;)</code>,删除使用<code>classmates.pop()</code>,pop(i)则是删除指定元素</p></li><li><p>list里面的元素的数据类型也可以不同，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">&#x27;Apple&#x27;</span>, <span class="number">123</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure></li><li><p>list元素也可以是另一个list，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, [<span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;php&#x27;</span>], <span class="string">&#x27;scheme&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p>元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改<code>classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</code>,只有1个元素的tuple定义时必须加一个逗号<code>,</code>t = (1,)</p></li></ul><h4 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a><strong>dict和set</strong></h4><ul><li><p>Python内置了字典：dict的支持</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=&quot;headerlink&quot; title=&quot;Python&quot;&gt;&lt;/a&gt;Python</summary>
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="tag5" scheme="http://example.com/tags/tag5/"/>
    
  </entry>
  
  <entry>
    <title>深度学习tips</title>
    <link href="http://example.com/2021/03/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/03/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-21T07:12:19.075Z</published>
    <updated>2021-03-21T07:18:36.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机<a id="more"></a></h3><ul><li><p>感知机是具有输入和输出的算法。给定一个输入后，将输出一个既<br>定的值。</p></li><li><p>感知机将权重和偏置设定为参数。</p></li><li><p>使用感知机可以表示与门和或门等逻辑电路。</p></li><li><p>异或门无法通过单层感知机来表示。</p></li><li><p>使用2层感知机可以表示异或门。</p></li><li><p>单层感知机只能表示线性空间，而多层感知机可以表示非线性空间。</p></li><li><p>多层感知机（在理论上）可以表示计算机。</p></li><li><p>神经网络中使用的是平滑变化的sigmoid函数，而感知机中使用的是信号急剧变化的阶跃函数。</p></li></ul><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a><strong>神经网络</strong></h3><ul><li>神经网络中的激活函数使用平滑变化的sigmoid函数或ReLU函数。</li><li>通过巧妙地使用NumPy多维数组，可以高效地实现神经网络。</li><li>机器学习的问题大体上可以分为回归问题和分类问题。</li><li>关于输出层的激活函数，回归问题中一般用恒等函数，分类问题中<br>一般用softmax函数。</li><li>分类问题中，输出层的神经元的数量设置为要分类的类别数。</li><li>输入数据的集合称为批。通过以批为单位进行推理处理，能够实现高速的运算。</li></ul><h3 id="神经网络learn"><a href="#神经网络learn" class="headerlink" title="神经网络learn"></a><strong>神经网络learn</strong></h3><ul><li><strong>训练数据和测试数据</strong>：使用训练数据进行学习，寻找最优参数；使用测试数据评价所得模型的实际能力，我们所追求的是模型的泛化能力（处理未被观察过数据的能力）</li><li>只对某个数据集过度拟合的状态称为过拟合，需要避免。</li><li><strong>损失函数：</strong>神经网络以某个指标为线索寻找最优权重参数，学习中所用的指标为损失函数，该函数一般使用均方误差和交叉熵误差。</li><li>在进行神经网络的学习时，不能将识别精度作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。</li><li><strong>神经网络的学习：</strong>步骤1mini-batch，步骤2计算梯度，步骤3更新参数，步骤4，重复。</li><li></li></ul><h3 id="误差反向传播"><a href="#误差反向传播" class="headerlink" title="误差反向传播"></a><strong>误差反向传播</strong></h3><ul><li><strong>计算图：</strong>先构建计算图，从左往右运算（正向传播），反向传播局部导数，并乘上游传过来的值。</li><li>计算图的乘法节点为乘法层(MulLayer)，加法节点为加法层AddLayer，“层”是神经网络中功能的单位。比如，负责 sigmoid函数的Sigmoid、负责矩阵乘积的Affine等，都以层为单位进行实现。</li><li><strong>激活函数层实现：</strong>Relu层：如果正向传播时的输入值小于等于0，则反向传播的值为0；因此，反向传播中会使用正向传播时保存的mask，将从上游传来的dout的mask中的元素为True的地方设为0。</li><li>Sigmoid层：略</li><li>Affine：神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换”A。因此，这里将进行仿射变换的处理实现为“Affine层”；</li><li>输入图像通过Affine层和ReLU层进行转换，10个输入通过Softmax层进行正<br>规化。</li><li>神经网络中进行的处理有推理（inference）和学习两个阶段。神经网络的推理通常不使用 Softmax层。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要 Softmax层。不过，神经网络的学习阶段则需要 Softmax层。</li><li><strong>误差反向传播算法</strong>：层保存为OrderedDict有序字典，它可以记住向字典添加元素的顺序因此，神经网络的正向传播只需按照添加元素的顺序调用各层的forward()方法就可以完成处理，我们要做的只是按顺序调用各层。</li><li><strong>梯度确认：</strong>这里已经有两种求梯度的方法，一种为基于数值微分的方法，一种为解析性地求解数学式的方法（误差反向传播），前者运算时间长，但算法简单不易出错，后者运算快但实现复杂，确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致（严格地讲，是非常相近）的操作称为梯度确认。</li><li><strong>小结：</strong>计算图的节点是由局部计算构成的。局部计算构成全局计算。</li><li>计算图的正向传播进行一般的计算。通过计算图的反向传播，可以<br>计算各个节点的导数。</li><li>通过将神经网络的组成元素实现为层，可以高效地计算梯度（反向传<br>播法）。</li><li>通过比较数值微分和误差反向传播法的结果，可以确认误差反向传<br>播法的实现是否正确（梯度确认）。</li></ul><h3 id="学习技巧"><a href="#学习技巧" class="headerlink" title="学习技巧"></a>学习技巧</h3><ul><li><strong>Momentum：</strong>动量，该式中有αv这一项，在物体不受力时使物体减速，（α设定为小于1的小数）</li><li><strong>AdaGrad：</strong>学习率过大或过小都会影响到算法的执行，因此现在经常使用的为学习率衰减法；AdaGrad会为参数的每个元素适当地调整学习率，与此同时进行学习。</li><li><strong>Adam：</strong>融合了Momentum和AdaGrad的方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。此外，进行超参数的“偏置校正”也是Adam的特征。</li><li><strong>权重初始值：</strong>为了防止权重均一化，必须随机生成初始值。</li><li><strong>隐藏层的激活值分步</strong>：在ch06/weight_init_activation_histogram.py中，使用的sigmoid为s型函数，使用标准差为1的高斯分布作为权重初始值时，输出不断靠近0或1，它的导数值逐渐接近0，因此偏向0和1的数据分布造成反向传播梯度不断减小最后消失；这个问题为<strong>梯度消失</strong>。</li><li>将权重标准差设置为0.01，进行相同实验，这次呈集中在0.5附件的分布，这样多个神经元都几乎输出相同的值，那它们就没有存在的必要，1个神经元就可表达基本相同的事情，出现<strong>表现力受限</strong>的问题</li><li>各层的激活值的分布都要求有适当的广度。因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。</li><li>Xavier的论文中，为了使各层的激活值呈现出具有相同广度的分布，推导了合适的权重尺度。推导出的结论是，如果前一层的节点数为n，则初始值使用标准差为1/√n的分布。</li><li><strong>Batch Norm：</strong>Batch Norm的思路是调整各层的激活值分布使其拥有适当的广度。为此，要向神经网络中插入对数据分布进行正规化的层，即Batch Normalization层。使数据分布的均值为0、方差为1的正规化。</li><li>它可以使学习快速进行，不那么依赖初始值，抑制过拟合。</li><li><strong>权值衰减：</strong></li></ul><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a><strong>卷积神经网络</strong></h3><ul><li><strong>CNN的层</strong>连接顺序一般是Convolution-ReLu-Pooling，最后为Affine-Softmax。</li><li><strong>二维：</strong>假设输入大小为(H, W)，滤波器大小为(FH, FW)，输出大小为(OH, OW)，填充为P，步幅为S。OH=（H+2P-FH）/S+1，OW=（W+2P-FH）/S+1.</li><li><strong>池化层：</strong>对微小的位置变化具有鲁棒性，输入数据发生微小偏差时，池化仍会返回相同的结果。</li><li>一次5*5的卷积运算可以由两次3*3的卷积运算抵充，叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将 ReLU等激活函数夹在卷积层的中间，进一步提高<br>了网络的表现力。</li><li><strong>VGG：</strong>由卷积层和池化层构成的基础CNN，它的特点在于将有权重的层叠加至16或19层，基于3*3的的小型滤波器的卷积层的运算是连续进行的。</li><li><strong>GoogLeNet：</strong>特征为网络不仅在纵向有深度，在横向也有广度，在横向上有“宽度”，这称为“Inception结构”。   </li><li><strong>ResNet：</strong>导入了“快捷结构”，可以随着层的加深而提高性能（在一定限度内），快捷结构跳过了输入数据的卷积层，将输入x合计到输出，通过快捷结构，原来的2层卷积层的输出F(x)变成了F(x) + x。即使加深层，也能高效地学习，这是因为，通过快捷结构，反向传播时信号可以无衰减地传递。</li><li>ResNet通过以2个卷积层为间隔跳跃式地连接来加深层。</li><li>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;感知机&quot;&gt;&lt;a href=&quot;#感知机&quot; class=&quot;headerlink&quot; title=&quot;感知机&quot;&gt;&lt;/a&gt;感知机</summary>
    
    
    
    <category term="ML" scheme="http://example.com/categories/ML/"/>
    
    
    <category term="tag4" scheme="http://example.com/tags/tag4/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="http://example.com/2021/03/21/Git/"/>
    <id>http://example.com/2021/03/21/Git/</id>
    <published>2021-03-21T07:09:50.321Z</published>
    <updated>2021-03-21T07:11:41.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git<a id="more"></a></h2><h5 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h5><ol><li><p>首先选择一个合适的位置，创建空目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Hello</span><br><span class="line">cd Hello</span><br></pre></td></tr></table></figure></li><li><p>把该目录变成可以由git管理的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>这样git的仓库就构建完成，该目录下还多了一个.git目录，它为隐藏目录可通过ls -ah看到。</p></li><li><p>接下来新建一个文件<code>vim hello.sh</code></p></li><li><p><code>git add hello.sh</code> ，把文件添加到仓库。</p></li><li><p><code>git commit -m &#39;write a hello file&#39;</code>,把文件提交到仓库，-m后是本次输入的说明，在之后查看历史记录能很方便地找到自己所做过的修改。</p></li><li><p><code>git status</code>查看仓库当前的状态，如果修改了仓库中的某文件，那查看这个状态可以看到文件被修改过。</p></li><li><p><code>git diff</code>可以看到具体修改了什么内容，知道做出什么修改后，就可放心地将文件提交到仓库了。</p></li></ol><h5 id="时光机"><a href="#时光机" class="headerlink" title="时光机"></a>时光机</h5><ol><li><strong>版本回退</strong>：<code>git log</code>命令显示最近到之前的提交日志，可以加上–pretty=oneline参数，就可只显示版本号和提交说明。</li><li>在git中，HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上两个版本，至于上100个版本，为HEAD~100。</li><li><code>git reset --hard HEAD^</code>，回到上一个版本，这时，<code>cat hello.sh</code>显示出的内容为上一次提交的内容，且<code>git log</code>,显示的提交日志，也没有了之前最后一次提交。但若页面不关闭，我们可以通过之前<code>git log</code>显示的日志看到版本号，只要通过<code>git reset --hard [版本号]</code>，就可以直接回到该版本号所表示的git版本。</li><li>但你若是回到之前版本后，第二天后悔了，可通过<code>git reflog</code>，看到每一次命令，那就可以看到之前的版本号。</li><li><strong>撤销修改</strong>：<code>git checkout -- first.sh</code>，把文件在工作区的修改撤销。</li><li><code>git rm</code>删除版本库中该文件，并且提交。rm删除工作区中文件。</li></ol><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><ol><li><strong>创建ssh key</strong>：<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>,在目录中找到.ssh目录，里面有id_rsa,id_rsa.pub文件，后者为公共密钥，在GitHub上添加ssh key，将id_rsa.pub文件内容粘贴到key文本框。</li><li><strong>关联远程库</strong>：<code>git remote add origin git@server-name:path/repo-name.git</code></li><li><code>git push -u origin master</code>推送本地库master所有内容到远程仓库，并将本地的master和远程连接起来，之后可<code>git push origin master</code>,把本地master分支最新修改推送到GIthub。</li></ol><h5 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h5><ol><li><p><strong>创建/切换分支</strong>：创建分支dev并切换到dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line">//相当于</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev//创建</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev//切换</span></span><br></pre></td></tr></table></figure></li><li><p><code>git branch</code>查看当前分支。在dev分支工作并提交后，切换回之前分支。</p></li><li><p><code>git merge dev</code>把dev分支的工作合并到当前分支上。</p></li><li><p><code>git branch -d dev</code>将dev分支删除。</p></li><li><p>之前撤销命令也使用git checkout，因此，为了避免迷惑，现在切换分支可使用switch。</p></li><li><p><strong>创建并切换到新的分支：</strong><code>git switch -c dev</code>。</p></li><li><p><strong>直接切换到已有分支</strong>：<code>git switch main</code>。</p></li><li><p><code>git log --graph</code>可以看到分支合并图。</p></li><li><p><code>git merge --no-ff -m &#39;merge with no-ff&#39; dev</code>,合并时禁用Fast forward，删掉分支后也能看到合并历史。</p></li><li><p><strong>Bug分支：</strong>当你出现bug时，你希望创建一个分支去修复该bug，但你在dev上的工作还没有完成提交，在这种情况下，可通过<code>git stash</code>将工作现场储存。</p></li><li><p>然后到main分支，创建issue分支，修复bug并提交（记住这次的commit），然后回到main合并该分支，再将其删除。</p></li><li><p>此时可回到dev分支继续完成任务，<code>git stash list</code>看到之前的工作现场被存放，可以通过下列代码将其恢复。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply//恢复但stash内容不删除，可指定恢复哪个stash</span><br><span class="line">git stash drop//删除stash内容</span><br><span class="line"></span><br><span class="line">git stash pop//恢复并删除stash内容</span><br></pre></td></tr></table></figure></li><li><p>main上的bug被修复后，dev作为早期从main上创建的分支，上面也有这种bug，可以通过<code>git cherry-pick [修复bug时的commit]</code>，直接将那次修改复制到当前。</p></li><li><p><strong>丢弃未合并分支</strong>：<code>git branch -D [name]</code>，强制删除。</p></li></ol><h5 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h5><ol><li><p><code>git tag v1.0</code>，对最新提交的commit打上标签。</p></li><li><p>通过<code>git log</code>，查看历史提交的commit可对指定的打上标签<code>git tag v0.9 be99e86</code>。</p></li><li><p><code>git tag</code>查看所有标签，<code>git show v0.9</code>查看该标签信息。</p></li><li><p>创建带有说明的标签：<code>git tag -a v0.1 -m &quot;version 0.1 released&quot; be99e86</code>，查看信息时能看到该说明标签。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git</summary>
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="tag3" scheme="http://example.com/tags/tag3/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="http://example.com/2021/03/21/%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/"/>
    <id>http://example.com/2021/03/21/%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/</id>
    <published>2021-03-21T07:07:57.819Z</published>
    <updated>2021-03-21T07:18:32.871Z</updated>
    
    <content type="html"><![CDATA[<h4 id="搭梯子（建ss服务器）"><a href="#搭梯子（建ss服务器）" class="headerlink" title="搭梯子（建ss服务器）"></a>搭梯子（建ss服务器）<a id="more"></a></h4><ul><li><p><strong>购买VPS服务器</strong></p><ol><li>通过<a href="https://www.vultr.com/?ref=7048874">vultr链接</a>注册vultr账户。</li><li>选择服务器：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%B5%81%E7%A8%8B%E6%88%AA%E5%9B%BE.png" alt="流程截图" style="zoom: 25%;" />,</li><li>选择服务器位置：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%B5%81%E7%A8%8B%E6%88%AA%E5%9B%BE2.png" alt="流程截图2" style="zoom:25%;" /></li><li>选择服务器类型：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%B5%81%E7%A8%8B%E6%88%AA%E5%9B%BE3.png" alt="流程截图3" style="zoom:25%;" />，后面搭建过程使用到的脚本支持centos7或6（个人习惯使用7）。</li><li>最后服务器配置，选$3.5/mo即可，$2.5/mo的ipv6未必每个人都能使用。</li><li>最后点击部署即可，然后可在这找到ip和密码：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%B5%81%E7%A8%8B%E6%88%AA%E5%9B%BE4.png" alt="流程截图4" style="zoom:25%;" /></li></ol></li></ul><ul><li><p><strong>部署VPS服务器</strong></p><ol><li>windows用户下载xshell远程连接工具（可直接找盗版），点击文件—新建。</li></ol></li></ul><ol start="2"><li><img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f787368656c6c31322e706e67" alt="img" style="zoom:33%;" />接下来，用户名自己设置，一般使用root，登录密码为购买服务器后所得的密码，就可连接成功。<ol start="3"><li>若出现连接不上服务器的情况可删除原来的，重新开新的服务器（这不需要额外花钱，直接在原来那个网站更换即可）。</li></ol></li></ol><ul><li><p><strong>用脚本部署管理</strong>（不会sao操作只能用用别人的脚本</p><ol><li><p>先安装wget：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure></li><li><p>再安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></li><li><p>安装完成后的进入管理界面的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure></li><li><p>输入1安装SSR服务端。然后自己设置端口和ssr密码，端口为40-65535。</p></li><li><p>选择加密方式：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f33322e706e67" alt="img" style="zoom: 33%;" />，比如输入10。</p></li><li><p>接下来为协议插件：和上面界面类似，就不再截图了，输入默认的2，再下一步就是设置混淆插件，同上，输入1，plain。</p></li><li><p>完成上述步骤后就是对设备数，限速等的设置，除非个人有需求，否则全部直接默认回车就可。</p></li><li><p>完成这些就能看到自己的信息：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%9C%80%E5%90%8E%E4%BF%A1%E6%81%AF.png" alt="最后信息" style="zoom:50%;" />。</p></li><li><p>想修改账号信息可通过上述命令进入管理界面，进行查看或修改等。</p></li><li><p><strong>防火墙：</strong>要正常使用还得将防火墙关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service//停止防火墙</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld.service//禁止防火墙开机启动</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>加速VPS服务器</strong></p><ol><li><pre><code class="shell">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;chmod +x tcp.sh<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   安装TCP网络加速脚本。</span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;shell</span><br><span class="line">   .&#x2F;tcp.sh</span><br></pre></td></tr></table></figure>安装完成后通过该命令进入管理界面：&lt;img src=&quot;%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E5%8A%A0%E9%80%9F.png&quot; alt=&quot;加速&quot; style=&quot;zoom:33%;&quot; /&gt;，</code></pre></li><li><p>输入1安装BBR并重启，重启后再次进入该界面输入6启动加速。</p></li><li><p>最后下载SSR的Windows客户端，<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">下载地址</a>。进入文件夹启动exe程序，可看到屏幕右下角出现飞机图案。</p></li><li><p>输入bash ssr.sh，输入5查看信息，将ssr链接复制，右键点击飞机图案，点从剪切板批量导入ssr链接即可。</p></li><li><p>最后安装chrome插件，该插件下载<a href="https://github.com/atrandys/trojan/releases/download/1.0.0/SwitchyOmega_Chromium.crx">switchyomega</a>，下载完右键点击该文件，把crx后缀改为zip后缀，并解压到当前目录。打开谷歌浏览器，进入设置，添加扩展程序，这里添加解压后的文件即可。</p></li><li><p>添加完后会自动跳转到switchyomega页面，点击proxy，可改名为SSR，然后将代理服务器写为127.0.0.1，代理端口为1080。</p></li><li><p>如图：<img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f416c76696e393939392f5041432f64656d6f2f7373726b7a2e504e47" alt="img" style="zoom:33%;" />。</p></li><li><p>最后打开YouTube，就可以播放视频了。</p></li><li><p><img src="%E6%90%AD%E6%A2%AF%E5%AD%90%EF%BC%88%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89.assets/%E6%9C%80%E5%90%8E.png" alt="最后" style="zoom: 33%;" />。</p></li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;搭梯子（建ss服务器）&quot;&gt;&lt;a href=&quot;#搭梯子（建ss服务器）&quot; class=&quot;headerlink&quot; title=&quot;搭梯子（建ss服务器）&quot;&gt;&lt;/a&gt;搭梯子（建ss服务器）</summary>
    
    
    
    <category term="vpn" scheme="http://example.com/categories/vpn/"/>
    
    
    <category term="tag2" scheme="http://example.com/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Linux入门</title>
    <link href="http://example.com/2021/03/21/Linux%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/03/21/Linux%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-21T04:37:30.272Z</published>
    <updated>2021-03-21T07:13:31.404Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门<a id="more"></a></h2></li><li><h4 id="一、常用命令："><a href="#一、常用命令：" class="headerlink" title="一、常用命令："></a><strong>一、常用命令：</strong></h4><ol><li><p>ls -a显示隐藏文件，ls /显示根目录，-h人性化</p></li><li><p>-rw-r–r–</p><p>-u所有者-g所属组-o其他人-                                                                                                                                                                                                                                                                                                                                                                                                                  </p><p>r读，w写，x执行</p></li><li><p>ls -d查看目录而不显示目录下信息，-i查看id链</p></li><li><p><strong>目录处理命令：</strong>mkdir -p递归创建；pwd显示当前绝对路径；cd ..回到上级目录；rmdir 删除空目录</p></li><li><p>cp -r复制目录，-p保留文件属性；mv 剪切；</p></li><li><p>rm -r删除目录，-f强制执行，一般rm -rf直接删所有（危）</p></li><li><p><strong>文件处理命令：</strong>touch创建文件；cat显示文件内容（不适合长文件），cat -n显示行号；tac反向显示内容；</p></li><li><p>more分页显示文件内容（空格/f翻页，enter换行，q退出，b回翻）；less和more类似，/+关键词可搜索，按n可往下找；</p></li><li><p>head -n显示指定行数；tail -n显示末尾指定行数，-f动态显示文章末尾内容</p></li><li><p><strong>链接：</strong>ln -s /etc/dj /tmp/dj.soft ，创建文件/etc/dj的软连接/tmp/dj.soft</p><p>​            ln 硬链接；删除原文件软连接失效，硬链接仍可使用，硬链接与原文件同步更新且同一个i结点</p></li><li><p><strong>权限管理命令：</strong>chmod [ugoa]（三个不同用户，a指所有）+-=rwx [文件1]，同时改多个不同用户用，分隔使用，例chmod g+w，o-r Dj.mod；权限r指4、w指2、x指1，rwx就是权限7，可以直接用数字更改权限，例如chmod 640 Dj.mod，权限就变为-rw-r—–；命令后加 -R递归更改目录下所有文件。</p></li><li><p>若所有用户都对目录有w权限，则可在这个目录下创建删除文件，对文件有w权限只表示能改变该文件内容，要删除该文件需要对目录有w权限；一般情况rx同时存在。</p></li><li><p>chown [用户] [文件或目录]，改变所有者，chgrp（格式相同），改变用户组。</p></li><li><p>umask 显示、设置文件的缺省权限，-S以rwx的形式显示新建文件缺省权限</p></li><li><p><strong>文件搜索命令：</strong>find /etc -name init,在目录/etc下查找文件init，*<strong><strong>init****<em>查找带有init的文件，init</em></strong></strong>查找以init开头的文件，init???可查找init开头后有三个字母的文件；-iname则查找时不区分大小写。</p></li><li><p>find / -size +204800在根目录查找大于100MB的文件；find /home -user Dj查找所有者为Dj的文件；find /etc -cmin -5在/etc目录下查找5分钟内被修改过属性的文件和目录，-amin访问时间，-mmin文件内容，-cmin文件属性，+5为超过5分钟；</p></li><li><p>find /etc -size +163840 -a -size -204800，在/etc下查找大于80MB小于100MB的文件；-a两个条件同时满足，-o两个条件满足其一；find /etc -name init -exec ls -l {} ;在/etc下查找init文件并显示详情信息，-exec改为-ok则执行时询问；</p></li><li><p>-type f查找文件，d目录，l软链接文件；-inum根据i结点查找；</p></li><li><p>locate init在文件资料库中查找，直接找到文件所在位置，需要资料库更新后才可找到，可以通过updatedb更新，/tmp为临时文件处，可能找不到。-i可忽略大小写</p></li><li><p>which 搜索命令所在目录及别名信息，whereis搜索命令所在目录及帮助文档路径</p></li><li><p><strong>grep</strong> -iv [指定字串] [文件]，在文件中搜索字串匹配的行并输出，-i忽略大小写，-v排除指定字串，-v ^#将以#为开头的注释排除。</p></li><li><p><strong>帮助命令：</strong>man [命令]查看命令的帮助，man services查看配置文件帮助信息，whatis [命令]得到简短信息apropos [配置文件]查看简短信息。命令 –help可显示主要信息，info。。。</p></li><li><p>help [命令]查找shell内置命令的帮助信息</p></li><li><p><strong>用户管理命令：</strong>useradd 添加新用户，passwd 设置用户密码，who查看登录用户信息，tty本地终端，pts远程终端，w更详细信息。</p></li><li><p><strong>压缩解压命令：</strong>gzip压缩文件不能为目录，且压缩后不保留原文件，gunzip解压缩。</p></li><li><p>tar 选项[-zcf] [压缩后文件名] [目录]，打包目录，-c打包、-v显示信息、-f指定文件名、-z打包的同时压缩、-x解压缩，对于tar.gz文件，压缩和解压时使用-zcf，-zxf</p></li><li><p>zip 选项[-r] [压缩后文件名] [文件或目录]压缩文件或目录，-r压缩目录，unzip解压缩。</p></li><li><p>bzip2 选项[-k] [文件]压缩文件，-k产生压缩文件后保留原文件，bunzip2解压缩，对于tar.bz2，压缩和解压时用-cjf，-xjf</p></li><li><p><strong>网络命令：</strong>write &lt;用户名&gt;，给用户发信息，以Ctrl+D保存结束。wall [信息]发广播信息给所有用户。mail [用户名]查看发送电子邮件。</p></li><li><p>ping [选项] IP地址，测试网络联通性，-c指定发送次数。ifconfig [网卡名称] [IP地址] 查看和设置网卡信息。last 显示登录信息；lastlog显示最后登录时间 ；traceroute [网址] 显示数据包到主机的路径。</p></li><li><p>netstat [选项]，显示网络相关信息，-t TCP协议、-u UDP协议、-l 监听、-r路由、-n 显示IP地址和端口号；例 -tlun 查看本机监听的端口、-an查看本机所有网络连接、-rn查看本机路由表。</p></li><li><p>setup设置网络，service network restart重启网络.</p></li><li><p>mount [-t 文件系统] [设备文件名] [挂载点]，[-t 文件系统]可省略，一般为mount /dev/sr0 /mnt/cdrom/挂载镜像。umount /dev/sr0卸载。</p></li><li><p><strong>关机重启：</strong>shutdown [选项] [时间]，-c取消前一个关机命令，-h关机，-r重启。其他关机命令：halt、powerroff、init 0、reboot；</p></li><li><p><strong>系统运行级别：</strong>0关机、1单用户、2不完全多用户，不含NFS服务、3完全多用户、4未分配、5图形界面、6重启。init 5进图形界面。</p></li><li><p>cat /etc/inittab修改系统默认运行级别，runlevel查询系统运行级别，logout退出登录</p></li><li><p>dd if=输入文件 of=输出文件 bs=字节数 count=个数，用于磁盘复制。</p></li><li><p>grep [选项] “搜索内容” 文件名，-i忽略大小写，-n输出行号，-v反向查找，–color=auto搜索出的关键字用颜色显示。</p></li></ol></li><li><h4 id="二、Vim"><a href="#二、Vim" class="headerlink" title="二、Vim"></a><strong>二、Vim</strong></h4><ol><li><strong>常用操作：</strong>a在光标所在字符后插入，A在行尾插入；i在光标所在字符前插入，I在行首插入；o在光标下插入新行，O在光标上插入新行。</li><li><strong>定位命令：</strong>：set nu设置行号，set nonu取消行号，gg到第一行，G到最后一行，：n到第n行，$移至行尾，0移至行首。<ol start="3"><li><strong>删除命令：</strong>x删除光标所在字符，nx删除光标后n个字符，dd删除光标所在行，dG删除光标所在行到文件末尾内容，D删除光标所在处到行尾内容，：n1，n2d删除指定范围行。</li></ol></li><li><strong>复制：</strong>yy复制当前行，nyy复制当前行以下n行，dd剪切当前行，ndd剪切以下n行，p或P粘贴在当前光标所在行下或行上。<ol start="5"><li><strong>替换或取消：</strong>r取代光标所在处字符，R从光标所在处开始替换字符，按Esc结束，u取消上一步操作。</li></ol></li><li><strong>搜索和搜索替换：</strong>/string 搜索指定字符串，set ic搜索时忽略大小写；n搜索指定字符串的下一个出现位置；:%s/old/new/g全文替换指定字符串；:n1,n2s/old/new/g在一定范围内替换指定字符串。<ol start="7"><li><strong>保存和退出：</strong>:w保存修改，：w new_filename另存为指定文件，：wq保存修改并退出，ZZ保存修改并退出，：q！不保存修改退出，：wq！保存修改并退出（文件所有者和root可用）。</li></ol></li><li><strong>技巧：</strong>：r [文件]将文件内容导入，r ![命令]，将命令执行结构导入。map 快捷键 触发命令，定制快捷键执行命令。连续行注释：:n1,n2s/^/#/g、:n1,n2s/^#//g、:n1,n2s/^////g。替换：:ab [字符串1] [字符串2]，输入字符串1按空格或回车即可自动变为字符串2.</li></ol></li><li><h4 id="三、软件包"><a href="#三、软件包" class="headerlink" title="三、软件包"></a><strong>三、软件包</strong></h4><ol><li><strong>安装：</strong>rpm -ivh 包全名，-i安装、-v显示详细信息、-h显示进度、–nodeps不检测依赖性。升级：rpm -Uvh 包全名。卸载：rpm -e 包名。</li><li><strong>查询：</strong>rpm -q 包名，-qa查询所有已安装包。rpm -qi 包名，-i查询软件信息、-p查询未安装包信息。rpm -ql 包名，查询包中文件安装位置。rpm -qf 系统文件名，查询系统文件属于哪个包。rpm -qR 包名，查询软件包的依赖性，一般加-p查询未安装包的依赖性。<ol start="3"><li><strong>校验和提取：</strong>rpm -V 已安装包名，校验指定rpm包中的文件。rpm包中文件提取，rpm2cpio 包全名 | cpio -idv .文件绝对路径。（rpm2cpio将rpm包转化为cpio格式的命令，cpio是一个标准工具，用于创建软件档案文件和从档案文件中提取文件）。cpio 选项 &lt;[文件|设备]，-i还原、-d还原时自动新建目录、-v显示还原过程。</li></ol></li><li><strong>yum：</strong>yum list 查询可用软件包，yum search 关键字，搜索和关键字相关的包。yum -y update 包名，升级，remove卸载。软件组：yum grouplist列出可用软件组，groupinstall 软件组名，安装指定软件组，groupremove卸载。<ol start="5"><li>源码包：rpm包安装的默认路径是/etc/rc.d/init.d，源码包的安装不在默认路径，一般安装在/usr/local/，源代码在/usr/local/src</li></ol></li></ol></li><li><h4 id="四、用户和用户组管理"><a href="#四、用户和用户组管理" class="headerlink" title="四、用户和用户组管理"></a><strong>四、用户和用户组管理</strong></h4></li><li><h4 id="七、shell"><a href="#七、shell" class="headerlink" title="七、shell"></a><strong>七、shell</strong></h4><ol><li><p><strong>echo</strong> [选项] [内容]，输出内容，-e支持反斜线控制的字符转换。echo -e “\e[1;31m lcdj \e[0m”输出红色lcdj。以\e[1;起，以\e[0m结，31m代表红色。</p></li><li><p><strong>脚本：</strong>开头#!/bin/bash,执行脚本时，可通过绝对路径运行，也可./hello.sh相对路径运行，还可bash hello.sh运行。dos2unix 文件，可将window中编写的文件转化为Linux可用格式的文件。</p></li><li><p><strong>历史命令：</strong>history [选项]，-c清空历史命令，-w把缓存中的历史命令写入历史命令保存文件~/.bash_history。!n重复执行第n条历史命令，!!重复执行上一条命令，!字串，重复执行最后一条以该字串开头的命令。</p></li><li><p><strong>别名：</strong>alias 别名=‘原命令’，设定命令别名，alias查询命令别名。让别名永久生效，vim /root/.bashrc</p></li><li><p><strong>重定向符号示例：</strong>命令 &gt;(&gt;&gt;) 文件,分别以覆盖、追加的方式把命令的正确输出输出到文件或设备；错误命令 2&gt;(&gt;&gt;) 文件分别以覆盖、追加的方式把命令的错误输出输出到文件或设备。命令 &gt;&gt; 文件1 2&gt;&gt; 文件2，把正确输出追加到文件1，把错误输出追加到文件2；命令 &gt; 文件 2&gt;&amp;1分别以覆盖的方式把正确输出和错误输出保存到一个文件中；命令 &amp;&gt; 文件以覆盖的方式把正确错误都保存在同一个文件；命令 &lt; 文件1 &gt; 文件2 命令，把文件1作为输入，文件2作为输出。</p></li><li><p><strong>输入重定向：</strong>wc [选项] 文件，-c统计字节，-w统计单词，-l统计行数。命令 &lt; 文件，把文件作为命令的输入。</p></li><li><p><strong>多命令顺序执行：</strong>命令 ； 命令2，多个命令顺序执行，命令间无逻辑关系。命令 &amp;&amp; 命令，就算逻辑连接词的一般理解。命令 || 命令，同上。管道：命令1 | 命令2，命令1的正确输出作为命令2的操作对象。</p></li><li><p><strong>通配符：</strong>?匹配任意一个字符，*匹配任意0个或多个字符，[]匹配括号中任意一个字符，[a-z]匹配范围内一个字符，中括号里^0-9表示匹配的不是一个数字。</p></li><li><p><strong>用户自定义变量：</strong>变量不能以数字开头，Bash中变量默认为字符串型。可aa=${aa}[字符串]来叠加。可将命令结果作为变量赋值给一个自定义变量，例如：name=$(date),echo $name.</p></li><li><p><strong>环境变量：</strong>export 变量名 = 变量值，申明变量。env查询变量，unset删除。</p></li><li><p><strong>PATH：</strong>系统查找命令的路径，一般自己写的脚本不放入原有系统目录，一般PATH=”$PATH”:[脚本所在路径]，变量叠加可临时使用。</p></li><li><p><strong>PS1：</strong>花哨(略)。</p></li><li><p><strong>位置参数变量：</strong>$n,$0代表命令本身，$1-$9指第1到第9个参数，十以上的参数应${10}。$*指命令行中所有的参数，并把他们看成一个整体。$@指命令行中所有参数，并把他们区分对待。$#指命令行中所有参数的个数。</p></li><li><p><strong>预定义变量：</strong>$?，最后一个命令的返回状态，0则表示正确执行。$$当前进程号（PID）。$！后台运行的最后一个进程号（PID）。在命令后加&amp;表示把命令放入后台执行。</p></li><li><p>接收键盘输入：<strong>read</strong> [选项] [变量名]，-p “提示信息”，-t 秒数，指定read等待用户输入的时间，-n 字符数，read命令只接收指定的字符数就会执行，-s 隐藏数据的输入。</p></li><li><p><strong>数值运算：</strong>$((运算式)),或$[运算式]。</p></li><li><p><strong>变量测试和内容替换：</strong>暂略。</p></li><li><p><strong>正则：</strong></p></li><li><p><strong>环境变量配置文件：</strong>source 配置文件或. 配置文件。</p></li><li><p><strong>字符截取（需要自查）：</strong>cut [选项] 文件名，-f提取第几列，-d按照指定分隔符分割列。awk：自查。sed轻量级流编辑器。sed [选项] ‘[动作]’ 文件，-n把经过sed处理的行输出到屏幕，-e允许对输入数据应用多余的sed命令编辑，-i用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。</p></li><li><p><strong>字符处理：</strong>排序：sort [选项] 文件，-f忽略大小写，-n以数值型进行排序，默认是字符串型排序，-r反向排序，-t指定分隔符，默认为制表符，-k n[,m]按照指定的字段范围排序。统计：wc [选项] 文件，-l只统计行数，-w只统计单词数，-m只统计字符数。</p></li><li><p><strong>条件判断：</strong>text [选项] 文件。具体选项太多，用时可随时查，常用的有：-e判断文件是否存在，-d判断是否为目录文件，-f判断是否为普通文件。判断也可用[ ]。</p></li><li><p>[-eq]等于，[-ne]不等于，[-gt]大于，[-lt]小于，[-ge]大于等于，[-le]小于等于。</p></li><li><p>按照文件权限判断：-r判断文件是否拥有读权限，-w判断文件是否有写权限，-x判断文件是否有执行权限，上述判断均先判断文件是否存在。</p></li><li><p>文件比较：文件1 -nt 文件2，判断文件1是否比文件2新；-ot则判断是否旧；-ef判断两个文件inode号是否一致，一般用于判断一个是否为另一个的硬链接。数值、字符串比较：略。</p></li><li><p>多重条件判断：判断1 -a 判断2，相当于逻辑与；判断1 -o 判断2，相当于逻辑或；！判断，逻辑非。</p></li><li><p><strong>流程控制：</strong> </p></li><li><p><strong>tee:</strong> 屏幕输出且保存到文件（覆盖），-a双向追加重定向。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello | tee hello.txt,</span><br></pre></td></tr></table></figure></li><li><p>uniq 去除连续的重复行，-i忽略大小写，-c统计重复行次数，-d只显示重复行。</p></li></ol></li><li><h4 id="八、Linux管理"><a href="#八、Linux管理" class="headerlink" title="八、Linux管理"></a>八、Linux管理</h4><ol><li>服务管理：</li><li><strong>系统管理：</strong>ps aux查看所有进程（BSD系统格式），ps -le同上（Linux标准格式）。</li><li><strong>top</strong> [选项]，-d 秒数，指定top命令每隔几秒更新，默认为3秒。在交互中，？或h显示交互模式的帮助，P以CPU使用率排序，默认就是这个，M以内存的使用率排序，N以PID排序，q退出。pstree [选项]，查看进程树，-p显示PID，-u显示进程的所属用户。</li><li><strong>kill</strong> -l显示信号，信号代号1，SIGHUP，关闭进程然后重启，9，SIGKILL强制终止，15，SIGTERM，kill的默认信号，正常结束进程。pkill [选项] [信号] 进程名，按照进程名终止进程，-t 终端号，按照终端号踢出用户。</li><li><strong>把进程放入后台：</strong>在命令后加&amp;，进程放入后台后继续运行，ctrl+z把进程放入后台并暂停执行。jobs 查看后台的工作，-l显示工作的PID。fg %工作号，将后台暂停的工作恢复到前台执行。（注意区分工作号和PID），bg则是恢复到后台工作。</li><li><strong>系统资源查看：</strong>vmstat [刷新延迟 刷新次数]，监控系统资源。dmesg开机时内核检测信息。</li><li>free [选项]，查看内存使用状态，-b以字节为单位显示，-k以KB为单位（默认），-m以MB，-g以GB。</li><li>uname查看系统与内核相关信息，-a查看系统所有相关信息，-r查看内核版本，-s查看内核名称。file /bin/ls查看系统位数。</li><li>lsof列出进程调用的文件，-c 字符串，只列出以字符串开头的进程打开的文件；-u 用户名只列出某个用户的进程打开的文件；-p PID，列出某个PID进程打开的文件。</li><li><strong>系统定时任务：</strong>crontab [选项]，-e编辑crontab定时任务，-l查询crontab任务，-r删除当前用户所有的crontab任务。标准格式为* * * * * command，*从左到右代表分、时、日、月、周几。</li><li>日志管理：</li><li>运行级别：runlevel查看运行级别命令，init 运行级别，改变运行级别。</li><li>grub：</li><li><strong>备份：</strong>dump [选项] 备份之后的文件名 原文件，-level 0-9备份级别，-f 文件名，指定备份之后的文件名，-u备份成功后把备份时间记录在/etc/dumpdates，-v显示备份过程中更多输出信息，-j调用bzlib库压缩备份文件成.bz2格式，-W显示允许被dump的分区的备份等级及时间。</li><li>restore [模式选项] [选项]，模式：-C比较备份数据和实际数据的变化，-i进入交互模式，手工选择需要恢复的文件，-t查看模式，用于查看备份文件中拥有哪些数据，-r还原模式，用于数据还原。选项：指定备份文件的文件名。</li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;Linux入门&quot;&gt;&lt;a href=&quot;#Linux入门&quot; class=&quot;headerlink&quot; title=&quot;Linux入门&quot;&gt;&lt;/a&gt;Linux入门</summary>
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="tag1" scheme="http://example.com/tags/tag1/"/>
    
  </entry>
  
</feed>
